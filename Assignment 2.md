## Syntax Analysis<a name="Syntax-Analysis"></a>

**Aim**: To make a Syntax Analyzer to process stream of tokens generated by lexical analyzer and generate abstract syntax tree for our custom language CAUCHY.

**Input**: 
```go
fn add(a: int, b: int) int {
  let c:int = a + b;
  return c; 
}

fn main() {
  let a:int = input();
  let b:int = input();
  let c:int = add(a,b);
  jump(L,(c != 12));
  print("Equal!");
  jump(M, true);
  L: {
    print("Not equal");
  }
  M: {}
  return 0; 
}
```

**Explanation**: 
The YACC tool takes tokens as specified by the `cauchylex.l` file generate with LEX. We specify the grammar rules in the `parse.y` file.  

The `input.txt` file is then parsed by the program to check for any syntax violations. If such is the case then error is thrown along with the number at which the violation has occurred.

**Source Code**: `parse.y`

```c
%{
	/* Define header file, macros*/
    #include <stdio.h>
    #include <stdlib.h>
									
	extern FILE *yyin;					/* Loading external file as input */
	extern int yyparse();
	extern int yylex();
	extern void yyerror(char *);
	extern int yylineno;
	extern int yywrap();
	int errors = 0;
    int sym[26];
%}


/*DEFINITION SECTION*/

/*========== TOKENS ==========*/
%debug
%token LITERAL 
%token TYPE 
%token ID 
%token LABEL 

/*Keywords*/
%token FN 
%token MAIN 
%token LET 
%token PRINT 
%token INPUT 
%token RETURN 
%token JUMP 

/*Symbols*/
%token COLON 
%token SEMICOLON 
%token SECTION_OPEN 
%token SECTION_CLOSE
%token LEFTPAREN
%token RIGHTPAREN
%token ASSIGN 
%token COMMA

/*Arithmetic Operations*/
%token MINUS
%token ADD
%token MULTIPLY
%token DIVIDE
%token MOD

/*Logical Operations*/
%token NOT
%token AND
%token OR

/*Relational Operations*/
%token EQ
%token NE
%token GT
%token GTE
%token LT
%token LTE

/*========== START SYMBOL ==========*/
%start program								/* Specify Starting grammar symbol*/
%type stmt


/*RULE SECTION*/
/*========== GRAMMAR RULES ==========*/
%%
program:		fn program 
				|
				/* NOTHING */
;

arithexp:		arithexp MINUS term 
				|
				arithexp ADD term 
				|
				term 
;

term:			term MULTIPLY factor 
				|
				term DIVIDE factor 
				|
				factor 
;

factor:			LEFTPAREN relexp RIGHTPAREN 
				|
				LITERAL 
				|
				ID		
				|
				MINUS arithexp 
;

relexp:			relexp OR A 
				|
				A 
;

A:				A AND B 
				|
				B 
;

B:				NOT B 
				|
				C 
;

C:				C GT D 
				|
				C GTE D 
				|
				C LT D 
				|
				C LTE D 
				|
				C EQ D 
				|
				C NE D 
				|
				D
;

D:				arithexp
				|
				LEFTPAREN relexp RIGHTPAREN
;
				

fn:				FN ID LEFTPAREN params RIGHTPAREN TYPE
					SECTION_OPEN 
						body
						returnstmt
					SECTION_CLOSE
				|
				FN MAIN LEFTPAREN params RIGHTPAREN TYPE
					SECTION_OPEN 
						body
						returnstmt
					SECTION_CLOSE
;

params:			ID COLON TYPE params_
				|
				/* NOTHING */
;

params_:		COMMA params 
				| 
				/* NOTHING */
;  

emptyarg:		/* NOTHING */
;  

args:			LITERAL args_
				|
				ID args_
;

args_:			COMMA args
				|
				/* NOTHING */
;

body:			body_ SEMICOLON body
				|
				/* NOTHING */
;  

body_:			declarStmt
				|
				jumpstmt
				|
				printstmt
				|
				labelstmt
				|
				callstmt
				|
				literalstmt
				|
				assignstmt
				|
				/* NOTHING */
;

printstmt:		PRINT LEFTPAREN 
					LITERAL
				RIGHTPAREN	
				|
				PRINT LEFTPAREN 
					ID 
				RIGHTPAREN	
				|
				PRINT LEFTPAREN 
					relexp 
				RIGHTPAREN	
;

jumpstmt:		JUMP LEFTPAREN
					LABEL COMMA relexp
				RIGHTPAREN
;

labelstmt:		LABEL COLON	
					SECTION_OPEN
						body
					SECTION_CLOSE
				
;

assignstmt:		ID ASSIGN relexp 
;

callstmt:		ID LEFTPAREN
					args RIGHTPAREN
				|
				ID LEFTPAREN
					emptyarg 
				RIGHTPAREN
;

declarStmt:		LET ID COLON TYPE ASSIGN INPUT LEFTPAREN RIGHTPAREN
				|
				LET ID COLON TYPE ASSIGN relexp 
				|
				LET ID COLON TYPE ASSIGN callstmt
;

literalstmt:	LITERAL literalstmt_	
;

literalstmt_:	COMMA literalstmt 
				| /* NOTHING */
;

returnstmt:		RETURN arithexp SEMICOLON		
				|
				RETURN relexp SEMICOLON		
				|
				RETURN ID SEMICOLON		
;

%%


/*AUXILLARY FUNCTIONS SECTION*/
#include "lex.yy.c"						/*Get tokens from output of FLEX*/

void yyerror(char *error) {				/*Define function body in case of error*/
	printf("yyerror[%d]: %s @ Line No - %d\n", ++errors, error, yylineno);
}

int main() {
	yyin = fopen("input.txt", "r");		/*Specify input file*/
	yyparse();
	printf("SYMBOL TABLE\n");
	for (int i = 0; i < 26; i++) {
		printf("%c: %d\n",i+97,sym[i]);
	}
	return 0;
}
```


**Conclusion** : We have succeeded in making a Syntax Analyzer using YACC Tool for Cauchy language by adding the corresponding grammar rules.